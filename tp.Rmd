---
title: "TP2 - Criminalité à Toronto"
author: "groupe B - Alexandre DAVY - Louis LIARD - Adrien SAVOYES - Louis SELLIER  - Karamoko Alpha DIALLO  - Paul ZANON  "
output: github_document
---

### Chargement librairies
```{r load-packages, message=FALSE}
library(tidyverse) 
library(dsbox) 
library(corrplot)
library(dplyr)
library(readxl)
library(outliers)
library(ggplot2)
library(tidyr)
library(plotly)
library(treemap)
library(RColorBrewer)
library(ggmap)
library(rpart)
library(rpart.plot)
library(DAAG)
```

### Chargement datasets

```{r load-data, message=FALSE}
budget <- read_csv("data/Budget_2022.csv")
Major_Crime <- read_csv("data/Major_Crime_Indicators.csv")
properties <- read_csv("data/properties.csv")
```
### Résummer des données

```{r fonction, message=FALSE}

my_summary <- function(x) {
  if(is.character(x) == TRUE)
  {
    uniqv <- unique(x)
    output1 = uniqv[which.max(tabulate(match(x, uniqv)))]
    names(output1) <- "mode"
    output2 = table(x)[output1]/length(x)
    names(output2) <- "freq"
    
    y <- x[x!=output1]
    uniqv <- unique(y)
    output3 = uniqv[which.max(tabulate(match(y, uniqv)))]
    names(output3) <- "mode 2"
    output4 = table(y)[output3]/length(x)
    names(output4) <- "freq 2"
    
    if(!is.na(output3))
    {
      return(c(output1,output2,output3,output4))
    }
    return(c(output1,output2))
  }
  if(is.numeric(x) == TRUE)
  {
    output1 <- summary(x)
    output2 <- sd(x)
    names(output2) <- "Ecart type"
    if(is.na(output2))
    {
        return(c(output1, output2))
    }
    output3 <- quantile(x)[4] - quantile(x)[2]
    names(output3) <- "IQR"
    
    output4 <- range(x)[2] - range(x)[1]
    names(output4) <- "Etendue"
    
    output5 <- var(x)
    names(output5) <- "Variance"
    
    output6 <- output2 / mean(x)
    names(output6) <- "coeficient de variation"
    
    return(c(output1, output2, output3,output4, output5, output6))
  }
  }

```

```{r summary, message=FALSE}
sapply(budget,my_summary)
sapply(Major_Crime,my_summary)
sapply(properties,my_summary)
```





```{r}
select_numeric_cols <- function(df) {
  numeric_cols <- sapply(df, is.numeric) # Détermine les colonnes numériques
  df_numeric <- df[, numeric_cols] # Sélectionne les colonnes numériques
  return(df_numeric) # Retourne le dataframe avec les colonnes numériques uniquement
}
```


```{r}
propertie_num <- select_numeric_cols(properties)
print(propertie_num)
```

```{r}
cor(propertie_num)
```
```{r}
cor_pro_num = cor(propertie_num)
```

```{r}
corrplot(cor_pro_num, type = "upper", order = "hclust", tl.col = 'black', tl.srt = 45)
```

```{r}
budget_num <- select_numeric_cols(budget)

```

```{r}
remove_variable <- function(data, var_name) {
  data[, var_name] <- NULL
  return(data)
}

budget_num2<- remove_variable(budget_num, "Fiscal_Year")
```


```{r}
cor(budget_num2)
```
```{r}
cor_bud2_num = cor(budget_num2)
```

```{r}
corrplot(cor_bud2_num, type = "upper", order = "hclust", tl.col = 'black', tl.srt = 45)
```


```{r}
Major_Crime_num <- select_numeric_cols(Major_Crime)
```

```{r}
Major_Crime_num2<- remove_variable(Major_Crime_num, "occurrenceyear")
Major_Crime_num3<- remove_variable(Major_Crime_num2, "occurrenceday")
Major_Crime_num4<- remove_variable(Major_Crime_num3, "occurrencedayofyear")


```


```{r}
cor(Major_Crime_num4)
```

```{r}
cor_maj4_num = cor(Major_Crime_num4)
```

```{r}
corrplot(cor_maj4_num, type = "upper", order = "hclust", tl.col = 'black', tl.srt = 45)
```

### Balayage des données

On regarde la présence d'outliers pour la dataset properties

```{r}
test <- grubbs.test(properties$`Price ($)`)
test

test <- grubbs.test(properties$`Price ($)`, opposite= TRUE)
test
```

Afin de vérifier s' il y a ou non présence de données aberrantes pour la base de données properties nous avons effectué le test de Grubbs pour le maximum et le minimum. Pour le maximum qui ici est égale à 32 500 000 on peut en conclure qu’ici ce n’est pas une donnée aberrante malgré le fait que la valeur soit très élevée. En effet, cette base de données recense le prix de l’immobilier et il est possible que certaines propriétés soient très chères.
Pour le minimum qui est de 0 dans ce cas la est une donnée aberrante. En effet, dans le cas du prix d’une propriété il est impossible que cette valeur soit égale a 0. De plus, il existe d’autres valeurs très faibles qui peuvent nous faire penser à la présence d’outliers. On peut donc en conclure que cette ligne est par conséquent fausse est doit être rectifiée.

Un autre indicateur montrant la présence d’outliers est le graphique en boîte à moustache. On peut voir ici par la présence de points noir représentant des outliers. Il va donc falloir faire en sorte de les supprimer afin d’avoir les données les plus lisses que possible.

```{r}
boxplot(properties$`Price ($)`)

```

```{r}
mediane <- median(properties$`Price ($)`, na.rm=TRUE)
properties$`Price ($)` <- ifelse(properties$`Price ($)` > quantile(properties$`Price ($)`, 0.75) + 1.5 * IQR(properties$`Price ($)`) | properties$`Price ($)` < quantile(properties$`Price ($)`, 0.25) - 1.5 * IQR(properties$`Price ($)`), mediane, properties$`Price ($)`)
```

Pour cela on cherche les outliers et on les remplace par la médiane qu’on a calculée à l’aide d'écart type. Après ça, on peut voir un graphique en boîte à moustache plus cohérent. Il reste cependant quelque point noir mais qui ne sont pas concidéré comme des outliers mais uniquement des valeurs élevées.

```{r}
boxplot(properties$`Price ($)`)
```

Par la suite dans le dataset Major_Crime nous avons analysé toutes les colonnes afin de faire apparaître la présence de données aberrantes. Pour cela, nous avons sélectionné les colonnes principales dans lesquelles des données aberrantes peuvent apparaître comme X,Y Mois, Jours, Année, heures…

On peut voir que pour les colonnes X et Y il y a la présence de 0 ce qui est impossible pour le cas des coordonnées. Nous avons donc supprimé toutes les lignes dans le cas où un 0 apparaissait. Pour les restes des colonnes aucune valeur aberrantes n'était présente.

```{r analyse, results='hide'}
table(Major_Crime$X)
table(Major_Crime$Y)
```

```{r , echo=FALSE}
table(Major_Crime$reportedyear)
table(Major_Crime$reportedmonth)
table(Major_Crime$reportedday)
table(Major_Crime$reporteddayofweek)
table(Major_Crime$reportedhour)
```

```{r, echo=FALSE}
table(Major_Crime$location_type)
```

```{r}
Major_Crime <- Major_Crime[Major_Crime$ Y!=0,]
```

### Visualisation

```{r graph1,echo=FALSE, include=TRUE, warning=FALSE,message=FALSE}
Major_Crimetest <- Major_Crime %>% mutate(
  offence = case_when(substr(offence,1,7) == "Assault" ~ "Assault",
                      substr(offence,1,10) == "Aggravated" ~ "Assault",
                      substr(offence,1,3) == "B&E" ~ "B&E",
                      substr(offence,1,7) == "Robbery" ~ "Robbery",
                      substr(offence,1,5) == "Theft" ~ "Robbery",
                      substr(offence,1,9) == "Discharge" ~ "Firearm",
                      substr(offence,1,3) == "Use" ~ "Firearm",
                      substr(offence,1,8) == "Pointing" ~ "Firearm",
                      substr(offence,1,3) == "Air" ~ "Firearm",
                      TRUE ~ offence))

Major_Crimetest$offence <- fct_infreq(Major_Crimetest$offence)

```

### Classification des types de criminalités des quartiers


### ACP


### ACm


### AFC


### Prédiction de la valeur foncières des maisons de la ville de Toronto

```{r}

properties <- properties %>% mutate(
  ClassPrice = case_when(`Price ($)` < quantile(properties$`Price ($)`)[1] ~ '1 quart',
                         `Price ($)` < quantile(properties$`Price ($)`)[2] ~ '2 quart',
                         `Price ($)` < quantile(properties$`Price ($)`)[3] ~ '3 quart',
                      TRUE ~ '4 quart'))



properties <- properties %>% mutate(Price = `Price ($)`/max(properties$`Price ($)`))





```


### regresion linéaire 
```{r}

model <- lm( `Price ($)` ~ lat + lng, data = properties, family = binomial)
model


```

```{r message=FALSE, warning=FALSE}
coef(model)
summary(model)
confint(model)
```

```{r}

properties$fitted = fitted(model)
head(properties$fitted)
```

### regresion logistique

```{r}
# Convertir les valeurs en dehors de l'intervalle [0,1] en 0 ou 1
properties$Price.... <- ifelse(properties$Price < 0, 0, properties$Price....)
properties$Price.... <- ifelse(properties$Price > 1, 1, properties$Price....)

# Ajuster le modèle de régression logistique binaire
model <- glm(Price.... ~ lat + lng, data = properties, family = binomial)
model
```


```{r message=FALSE, warning=FALSE}
coef(model)
summary(model)
confint(model)
```

```{r}

properties$fitted = fitted(model) * max(properties$`Price ($)`)
head(properties$fitted)
```

### arbre de décision 

```{r}


model1 <- rpart(ClassPrice ~ lat + lng, data = properties, method = "class",
                control = rpart.control(cp = 0.02))

rpart.plot(model1)
```

```{r}
data.predict = properties[c(1:10), ]

pred <- predict(model1, 
                newdata=data.predict, type = "class")
pred
```
















